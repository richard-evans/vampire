<!-- HTML header for doxygen 1.8.3.1-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.4"/>
<title>CUB: cub::DeviceRadixSort Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="extra_stylesheet.css" rel="stylesheet" type="text/css"/>
<link rel="shortcut icon" href="favicon.ico" type="image/x-icon" />
<script type="text/javascript">
  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38890655-1']);
  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">CUB
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.4 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Groups</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacecub.html">cub</a></li><li class="navelem"><a class="el" href="structcub_1_1_device_radix_sort.html">DeviceRadixSort</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="structcub_1_1_device_radix_sort-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">cub::DeviceRadixSort Struct Reference<div class="ingroups"><a class="el" href="group___single_module.html">Single-problem</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed description</h2>
<div class="textblock"><p><a class="el" href="structcub_1_1_device_radix_sort.html" title="DeviceRadixSort provides device-wide, parallel operations for computing a radix sort across a sequenc...">DeviceRadixSort</a> provides device-wide, parallel operations for computing a radix sort across a sequence of data items residing within device-accessible memory. </p>
<div class="image">
<img src="sorting_logo.png" alt="sorting_logo.png"/>
<div class="caption">
.</div></div>
 <dl class="section user"><dt>Overview</dt><dd>The <a href="http://en.wikipedia.org/wiki/Radix_sort"><em>radix sorting method</em></a> arranges items into ascending (or descending) order. The algorithm relies upon a positional representation for keys, i.e., each key is comprised of an ordered sequence of symbols (e.g., digits, characters, etc.) specified from least-significant to most-significant. For a given input sequence of keys and a set of rules specifying a total ordering of the symbolic alphabet, the radix sorting method produces a lexicographic ordering of those keys.</dd></dl>
<dl class="section user"><dt></dt><dd><a class="el" href="structcub_1_1_device_radix_sort.html" title="DeviceRadixSort provides device-wide, parallel operations for computing a radix sort across a sequenc...">DeviceRadixSort</a> can sort all of the built-in C++ numeric primitive types, e.g.: <code>unsigned char</code>, <code>int</code>, <code>double</code>, etc. Although the direct radix sorting method can only be applied to unsigned integral types, <a class="el" href="structcub_1_1_device_radix_sort.html" title="DeviceRadixSort provides device-wide, parallel operations for computing a radix sort across a sequenc...">DeviceRadixSort</a> is able to sort signed and floating-point types via simple bit-wise transformations that ensure lexicographic key ordering.</dd></dl>
<dl class="section user"><dt>Usage Considerations</dt><dd><ul>
<li><em>Dynamic parallelism</em>. <a class="el" href="structcub_1_1_device_radix_sort.html" title="DeviceRadixSort provides device-wide, parallel operations for computing a radix sort across a sequenc...">DeviceRadixSort</a> methods can be called within kernel code on devices in which CUDA dynamic parallelism is supported.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>The work-complexity of radix sort as a function of input size is linear, resulting in performance throughput that plateaus with problem sizes large enough to saturate the GPU. The following chart illustrates <a class="el" href="structcub_1_1_device_radix_sort.html#a4f555afa8ac2949d9fef49fad52a50d6" title="Sorts keys into ascending order. (~2N auxiliary storage required) ">DeviceRadixSort::SortKeys</a> performance across different CUDA architectures for uniform-random <code>uint32</code> keys. Performance plots for other scenarios can be found in the detailed method descriptions below.</dd></dl>
<div class="image">
<img src="lsb_radix_sort_int32_keys.png" alt="lsb_radix_sort_int32_keys.png"/>
</div>
 
<p>Definition at line <a class="el" href="device__radix__sort_8cuh_source.html#l00082">82</a> of file <a class="el" href="device__radix__sort_8cuh_source.html">device_radix_sort.cuh</a>.</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Methods</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">KeyT-value pairs</div></td></tr>
<tr class="memitem:a31d7224d3f6c6a9309a0b84571f25eb9"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT &gt; </td></tr>
<tr class="memitem:a31d7224d3f6c6a9309a0b84571f25eb9"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_radix_sort.html#a31d7224d3f6c6a9309a0b84571f25eb9">SortPairs</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, KeyT *d_keys_in, KeyT *d_keys_out, ValueT *d_values_in, ValueT *d_values_out, int num_items, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a31d7224d3f6c6a9309a0b84571f25eb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts key-value pairs into ascending order. (~<em>2N </em>auxiliary storage required)  <a href="#a31d7224d3f6c6a9309a0b84571f25eb9">More...</a><br/></td></tr>
<tr class="separator:a31d7224d3f6c6a9309a0b84571f25eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e0f38bafdc30403a68b3ff5c7b80027"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT &gt; </td></tr>
<tr class="memitem:a0e0f38bafdc30403a68b3ff5c7b80027"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_radix_sort.html#a0e0f38bafdc30403a68b3ff5c7b80027">SortPairs</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, DoubleBuffer&lt; ValueT &gt; &amp;d_values, int num_items, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a0e0f38bafdc30403a68b3ff5c7b80027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts key-value pairs into ascending order. (~<em>N </em>auxiliary storage required)  <a href="#a0e0f38bafdc30403a68b3ff5c7b80027">More...</a><br/></td></tr>
<tr class="separator:a0e0f38bafdc30403a68b3ff5c7b80027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add6a87f54c8058edba4b9e875bb0626a"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT &gt; </td></tr>
<tr class="memitem:add6a87f54c8058edba4b9e875bb0626a"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_radix_sort.html#add6a87f54c8058edba4b9e875bb0626a">SortPairsDescending</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, KeyT *d_keys_in, KeyT *d_keys_out, ValueT *d_values_in, ValueT *d_values_out, int num_items, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:add6a87f54c8058edba4b9e875bb0626a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts key-value pairs into descending order. (~<em>2N</em> auxiliary storage required).  <a href="#add6a87f54c8058edba4b9e875bb0626a">More...</a><br/></td></tr>
<tr class="separator:add6a87f54c8058edba4b9e875bb0626a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea53a40e665f2d5ed683a6655a3d188e"><td class="memTemplParams" colspan="2">template&lt;typename KeyT , typename ValueT &gt; </td></tr>
<tr class="memitem:aea53a40e665f2d5ed683a6655a3d188e"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_radix_sort.html#aea53a40e665f2d5ed683a6655a3d188e">SortPairsDescending</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, DoubleBuffer&lt; ValueT &gt; &amp;d_values, int num_items, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:aea53a40e665f2d5ed683a6655a3d188e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts key-value pairs into descending order. (~<em>N </em>auxiliary storage required).  <a href="#aea53a40e665f2d5ed683a6655a3d188e">More...</a><br/></td></tr>
<tr class="separator:aea53a40e665f2d5ed683a6655a3d188e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Keys-only</div></td></tr>
<tr class="memitem:a4f555afa8ac2949d9fef49fad52a50d6"><td class="memTemplParams" colspan="2">template&lt;typename KeyT &gt; </td></tr>
<tr class="memitem:a4f555afa8ac2949d9fef49fad52a50d6"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_radix_sort.html#a4f555afa8ac2949d9fef49fad52a50d6">SortKeys</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, KeyT *d_keys_in, KeyT *d_keys_out, int num_items, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a4f555afa8ac2949d9fef49fad52a50d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts keys into ascending order. (~<em>2N </em>auxiliary storage required)  <a href="#a4f555afa8ac2949d9fef49fad52a50d6">More...</a><br/></td></tr>
<tr class="separator:a4f555afa8ac2949d9fef49fad52a50d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b5dbc2e3fd44c21193f2b792706191"><td class="memTemplParams" colspan="2">template&lt;typename KeyT &gt; </td></tr>
<tr class="memitem:ad7b5dbc2e3fd44c21193f2b792706191"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_radix_sort.html#ad7b5dbc2e3fd44c21193f2b792706191">SortKeys</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, int num_items, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:ad7b5dbc2e3fd44c21193f2b792706191"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts keys into ascending order. (~<em>N </em>auxiliary storage required).  <a href="#ad7b5dbc2e3fd44c21193f2b792706191">More...</a><br/></td></tr>
<tr class="separator:ad7b5dbc2e3fd44c21193f2b792706191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24761009c4cc15fd2e54cb72663af0ef"><td class="memTemplParams" colspan="2">template&lt;typename KeyT &gt; </td></tr>
<tr class="memitem:a24761009c4cc15fd2e54cb72663af0ef"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_radix_sort.html#a24761009c4cc15fd2e54cb72663af0ef">SortKeysDescending</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, KeyT *d_keys_in, KeyT *d_keys_out, int num_items, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a24761009c4cc15fd2e54cb72663af0ef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts keys into descending order. (~<em>2N</em> auxiliary storage required).  <a href="#a24761009c4cc15fd2e54cb72663af0ef">More...</a><br/></td></tr>
<tr class="separator:a24761009c4cc15fd2e54cb72663af0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95a8939332405efec4527442c26c2628"><td class="memTemplParams" colspan="2">template&lt;typename KeyT &gt; </td></tr>
<tr class="memitem:a95a8939332405efec4527442c26c2628"><td class="memTemplItemLeft" align="right" valign="top">static CUB_RUNTIME_FUNCTION <br class="typebreak"/>
cudaError_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="structcub_1_1_device_radix_sort.html#a95a8939332405efec4527442c26c2628">SortKeysDescending</a> (void *d_temp_storage, size_t &amp;temp_storage_bytes, DoubleBuffer&lt; KeyT &gt; &amp;d_keys, int num_items, int begin_bit=0, int end_bit=sizeof(KeyT)*8, cudaStream_t stream=0, bool debug_synchronous=false)</td></tr>
<tr class="memdesc:a95a8939332405efec4527442c26c2628"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sorts keys into descending order. (~<em>N </em>auxiliary storage required).  <a href="#a95a8939332405efec4527442c26c2628">More...</a><br/></td></tr>
<tr class="separator:a95a8939332405efec4527442c26c2628"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a31d7224d3f6c6a9309a0b84571f25eb9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t cub::DeviceRadixSort::SortPairs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT *&#160;</td>
          <td class="paramname"><em>d_values_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT *&#160;</td>
          <td class="paramname"><em>d_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts key-value pairs into ascending order. (~<em>2N </em>auxiliary storage required) </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires an allocation of temporary device storage that is <em>O</em>(<code>N+P</code>), where <code>N</code> is the length of the input and <code>P</code> is the number of streaming multiprocessors on the device. For sorting using only <em>O</em>(<code>P</code>) temporary storage, see the sorting interface using DoubleBuffer wrappers below.</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>The following charts illustrate saturated sorting performance across different CUDA architectures for uniform-random <code>uint32,uint32</code> and <code>uint64,uint64</code> pairs, respectively.</dd></dl>
<div class="image">
<img src="lsb_radix_sort_int32_pairs.png" alt="lsb_radix_sort_int32_pairs.png"/>
</div>
 <div class="image">
<img src="lsb_radix_sort_int64_pairs.png" alt="lsb_radix_sort_int64_pairs.png"/>
</div>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the sorting of a device vector of <code>int</code> keys with associated vector of <code>int</code> values. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_in;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_out;      <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a31d7224d3f6c6a9309a0b84571f25eb9" title="Sorts key-value pairs into ascending order. (~2N auxiliary storage required) ">cub::DeviceRadixSort::SortPairs</a>(d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a31d7224d3f6c6a9309a0b84571f25eb9" title="Sorts key-value pairs into ascending order. (~2N auxiliary storage required) ">cub::DeviceRadixSort::SortPairs</a>(d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [0, 3, 5, 6, 7, 8, 9]</span></div>
<div class="line"><span class="comment">// d_values_out          &lt;-- [5, 4, 3, 1, 2, 0, 6]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> KeyT type </td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> ValueT type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Pointer to the input data of key data to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Pointer to the sorted output sequence of key data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_values_in</td><td>Pointer to the corresponding input sequence of associated value items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_values_out</td><td>Pointer to the correspondingly-reordered output sequence of associated value items </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="example_device_radix_sort_8cu-example.html#a2">example_device_radix_sort.cu</a>.</dd>
</dl>
<p>Definition at line <a class="el" href="device__radix__sort_8cuh_source.html#l00147">147</a> of file <a class="el" href="device__radix__sort_8cuh_source.html">device_radix_sort.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a0e0f38bafdc30403a68b3ff5c7b80027"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t cub::DeviceRadixSort::SortPairs </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; ValueT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts key-value pairs into ascending order. (~<em>N </em>auxiliary storage required) </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers and a corresponding pair of associated value buffers. Each pair is managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers within each pair may be altered by the sorting operation.</li>
<li>Upon completion, the sorting operation will update the "current" indicator within each DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits specified and the targeted device architecture).</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires a relatively small allocation of temporary device storage that is <em>O</em>(<code>P</code>), where <code>P</code> is the number of streaming multiprocessors on the device (and is typically a small constant relative to the input size <code>N</code>).</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>The following charts illustrate saturated sorting performance across different CUDA architectures for uniform-random <code>uint32,uint32</code> and <code>uint64,uint64</code> pairs, respectively.</dd></dl>
<div class="image">
<img src="lsb_radix_sort_int32_pairs.png" alt="lsb_radix_sort_int32_pairs.png"/>
</div>
 <div class="image">
<img src="lsb_radix_sort_int64_pairs.png" alt="lsb_radix_sort_int64_pairs.png"/>
</div>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the sorting of a device vector of <code>int</code> keys with associated vector of <code>int</code> values. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_buf;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_alt_buf;   <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a set of DoubleBuffers to wrap pairs of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line">cub::DoubleBuffer&lt;int&gt; d_values(d_value_buf, d_value_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a31d7224d3f6c6a9309a0b84571f25eb9" title="Sorts key-value pairs into ascending order. (~2N auxiliary storage required) ">cub::DeviceRadixSort::SortPairs</a>(d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a31d7224d3f6c6a9309a0b84571f25eb9" title="Sorts key-value pairs into ascending order. (~2N auxiliary storage required) ">cub::DeviceRadixSort::SortPairs</a>(d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [0, 3, 5, 6, 7, 8, 9]</span></div>
<div class="line"><span class="comment">// d_values.Current()    &lt;-- [5, 4, 3, 1, 2, 0, 6]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> KeyT type </td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> ValueT type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_values</td><td>Double-buffer of values whose "current" device-accessible buffer contains the unsorted input values and, upon return, is updated to point to the sorted output values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__radix__sort_8cuh_source.html#l00248">248</a> of file <a class="el" href="device__radix__sort_8cuh_source.html">device_radix_sort.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="add6a87f54c8058edba4b9e875bb0626a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t cub::DeviceRadixSort::SortPairsDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT *&#160;</td>
          <td class="paramname"><em>d_values_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ValueT *&#160;</td>
          <td class="paramname"><em>d_values_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts key-value pairs into descending order. (~<em>2N</em> auxiliary storage required). </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires an allocation of temporary device storage that is <em>O</em>(<code>N+P</code>), where <code>N</code> is the length of the input and <code>P</code> is the number of streaming multiprocessors on the device. For sorting using only <em>O</em>(<code>P</code>) temporary storage, see the sorting interface using DoubleBuffer wrappers below.</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>Performance is similar to <a class="el" href="structcub_1_1_device_radix_sort.html#a31d7224d3f6c6a9309a0b84571f25eb9" title="Sorts key-value pairs into ascending order. (~2N auxiliary storage required) ">DeviceRadixSort::SortPairs</a>.</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the sorting of a device vector of <code>int</code> keys with associated vector of <code>int</code> values. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_in;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_values_out;      <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#add6a87f54c8058edba4b9e875bb0626a" title="Sorts key-value pairs into descending order. (~2N auxiliary storage required). ">cub::DeviceRadixSort::SortPairsDescending</a>(d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#add6a87f54c8058edba4b9e875bb0626a" title="Sorts key-value pairs into descending order. (~2N auxiliary storage required). ">cub::DeviceRadixSort::SortPairsDescending</a>(d_temp_storage, temp_storage_bytes,</div>
<div class="line">    d_keys_in, d_keys_out, d_values_in, d_values_out, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [9, 8, 7, 6, 5, 3, 0]</span></div>
<div class="line"><span class="comment">// d_values_out          &lt;-- [6, 0, 2, 1, 3, 4, 5]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> KeyT type </td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> ValueT type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Pointer to the input data of key data to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Pointer to the sorted output sequence of key data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_values_in</td><td>Pointer to the corresponding input sequence of associated value items </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_values_out</td><td>Pointer to the correspondingly-reordered output sequence of associated value items </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__radix__sort_8cuh_source.html#l00328">328</a> of file <a class="el" href="device__radix__sort_8cuh_source.html">device_radix_sort.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="aea53a40e665f2d5ed683a6655a3d188e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT , typename ValueT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t cub::DeviceRadixSort::SortPairsDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; ValueT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_values</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts key-value pairs into descending order. (~<em>N </em>auxiliary storage required). </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers and a corresponding pair of associated value buffers. Each pair is managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers within each pair may be altered by the sorting operation.</li>
<li>Upon completion, the sorting operation will update the "current" indicator within each DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits specified and the targeted device architecture).</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires a relatively small allocation of temporary device storage that is <em>O</em>(<code>P</code>), where <code>P</code> is the number of streaming multiprocessors on the device (and is typically a small constant relative to the input size <code>N</code>).</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>Performance is similar to <a class="el" href="structcub_1_1_device_radix_sort.html#a31d7224d3f6c6a9309a0b84571f25eb9" title="Sorts key-value pairs into ascending order. (~2N auxiliary storage required) ">DeviceRadixSort::SortPairs</a>.</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the sorting of a device vector of <code>int</code> keys with associated vector of <code>int</code> values. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_buf;       <span class="comment">// e.g., [0, 1, 2, 3, 4, 5, 6]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_value_alt_buf;   <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a set of DoubleBuffers to wrap pairs of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line">cub::DoubleBuffer&lt;int&gt; d_values(d_value_buf, d_value_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#add6a87f54c8058edba4b9e875bb0626a" title="Sorts key-value pairs into descending order. (~2N auxiliary storage required). ">cub::DeviceRadixSort::SortPairsDescending</a>(d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#add6a87f54c8058edba4b9e875bb0626a" title="Sorts key-value pairs into descending order. (~2N auxiliary storage required). ">cub::DeviceRadixSort::SortPairsDescending</a>(d_temp_storage, temp_storage_bytes, d_keys, d_values, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [9, 8, 7, 6, 5, 3, 0]</span></div>
<div class="line"><span class="comment">// d_values.Current()    &lt;-- [6, 0, 2, 1, 3, 4, 5]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> KeyT type </td></tr>
    <tr><td class="paramname">ValueT</td><td><b>[inferred]</b> ValueT type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_values</td><td>Double-buffer of values whose "current" device-accessible buffer contains the unsorted input values and, upon return, is updated to point to the sorted output values </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__radix__sort_8cuh_source.html#l00424">424</a> of file <a class="el" href="device__radix__sort_8cuh_source.html">device_radix_sort.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a4f555afa8ac2949d9fef49fad52a50d6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t cub::DeviceRadixSort::SortKeys </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts keys into ascending order. (~<em>2N </em>auxiliary storage required) </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires an allocation of temporary device storage that is <em>O</em>(<code>N+P</code>), where <code>N</code> is the length of the input and <code>P</code> is the number of streaming multiprocessors on the device. For sorting using only <em>O</em>(<code>P</code>) temporary storage, see the sorting interface using DoubleBuffer wrappers below.</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>The following charts illustrate saturated sorting performance across different CUDA architectures for uniform-random <code>uint32</code> and <code>uint64</code> keys, respectively.</dd></dl>
<div class="image">
<img src="lsb_radix_sort_int32_keys.png" alt="lsb_radix_sort_int32_keys.png"/>
</div>
 <div class="image">
<img src="lsb_radix_sort_int64_keys.png" alt="lsb_radix_sort_int64_keys.png"/>
</div>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the sorting of a device vector of <code>int</code> keys. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line">void     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a4f555afa8ac2949d9fef49fad52a50d6" title="Sorts keys into ascending order. (~2N auxiliary storage required) ">cub::DeviceRadixSort::SortKeys</a>(d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a4f555afa8ac2949d9fef49fad52a50d6" title="Sorts keys into ascending order. (~2N auxiliary storage required) ">cub::DeviceRadixSort::SortKeys</a>(d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [0, 3, 5, 6, 7, 8, 9]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> KeyT type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Pointer to the input data of key data to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Pointer to the sorted output sequence of key data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__radix__sort_8cuh_source.html#l00506">506</a> of file <a class="el" href="device__radix__sort_8cuh_source.html">device_radix_sort.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="ad7b5dbc2e3fd44c21193f2b792706191"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t cub::DeviceRadixSort::SortKeys </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts keys into ascending order. (~<em>N </em>auxiliary storage required). </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers may be altered by the sorting operation.</li>
<li>Upon completion, the sorting operation will update the "current" indicator within the DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits specified and the targeted device architecture).</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires a relatively small allocation of temporary device storage that is <em>O</em>(<code>P</code>), where <code>P</code> is the number of streaming multiprocessors on the device (and is typically a small constant relative to the input size <code>N</code>).</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>The following charts illustrate saturated sorting performance across different CUDA architectures for uniform-random <code>uint32</code> and <code>uint64</code> keys, respectively.</dd></dl>
<div class="image">
<img src="lsb_radix_sort_int32_keys.png" alt="lsb_radix_sort_int32_keys.png"/>
</div>
 <div class="image">
<img src="lsb_radix_sort_int64_keys.png" alt="lsb_radix_sort_int64_keys.png"/>
</div>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the sorting of a device vector of <code>int</code> keys. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a DoubleBuffer to wrap the pair of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a4f555afa8ac2949d9fef49fad52a50d6" title="Sorts keys into ascending order. (~2N auxiliary storage required) ">cub::DeviceRadixSort::SortKeys</a>(d_temp_storage, temp_storage_bytes, d_keys, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a4f555afa8ac2949d9fef49fad52a50d6" title="Sorts keys into ascending order. (~2N auxiliary storage required) ">cub::DeviceRadixSort::SortKeys</a>(d_temp_storage, temp_storage_bytes, d_keys, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [0, 3, 5, 6, 7, 8, 9]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> KeyT type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__radix__sort_8cuh_source.html#l00595">595</a> of file <a class="el" href="device__radix__sort_8cuh_source.html">device_radix_sort.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a24761009c4cc15fd2e54cb72663af0ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t cub::DeviceRadixSort::SortKeysDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">KeyT *&#160;</td>
          <td class="paramname"><em>d_keys_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts keys into descending order. (~<em>2N</em> auxiliary storage required). </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The contents of the input data are not altered by the sorting operation</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires an allocation of temporary device storage that is <em>O</em>(<code>N+P</code>), where <code>N</code> is the length of the input and <code>P</code> is the number of streaming multiprocessors on the device. For sorting using only <em>O</em>(<code>P</code>) temporary storage, see the sorting interface using DoubleBuffer wrappers below.</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>Performance is similar to <a class="el" href="structcub_1_1_device_radix_sort.html#a4f555afa8ac2949d9fef49fad52a50d6" title="Sorts keys into ascending order. (~2N auxiliary storage required) ">DeviceRadixSort::SortKeys</a>.</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the sorting of a device vector of <code>int</code> keys. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_in;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_keys_out;        <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a DoubleBuffer to wrap the pair of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a24761009c4cc15fd2e54cb72663af0ef" title="Sorts keys into descending order. (~2N auxiliary storage required). ">cub::DeviceRadixSort::SortKeysDescending</a>(d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a24761009c4cc15fd2e54cb72663af0ef" title="Sorts keys into descending order. (~2N auxiliary storage required). ">cub::DeviceRadixSort::SortKeysDescending</a>(d_temp_storage, temp_storage_bytes, d_keys_in, d_keys_out, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys_out            &lt;-- [9, 8, 7, 6, 5, 3, 0]s</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> KeyT type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">d_keys_in</td><td>Pointer to the input data of key data to sort </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">d_keys_out</td><td>Pointer to the sorted output sequence of key data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__radix__sort_8cuh_source.html#l00670">670</a> of file <a class="el" href="device__radix__sort_8cuh_source.html">device_radix_sort.cuh</a>.</p>

</div>
</div>
<a class="anchor" id="a95a8939332405efec4527442c26c2628"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename KeyT &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static CUB_RUNTIME_FUNCTION cudaError_t cub::DeviceRadixSort::SortKeysDescending </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>d_temp_storage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>temp_storage_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DoubleBuffer&lt; KeyT &gt; &amp;&#160;</td>
          <td class="paramname"><em>d_keys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>begin_bit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_bit</em> = <code>sizeof(KeyT)&#160;*&#160;8</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cudaStream_t&#160;</td>
          <td class="paramname"><em>stream</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug_synchronous</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sorts keys into descending order. (~<em>N </em>auxiliary storage required). </p>
<dl class="section user"><dt></dt><dd><ul>
<li>The sorting operation is given a pair of key buffers managed by a DoubleBuffer structure that indicates which of the two buffers is "current" (and thus contains the input data to be sorted).</li>
<li>The contents of both buffers may be altered by the sorting operation.</li>
<li>Upon completion, the sorting operation will update the "current" indicator within the DoubleBuffer wrapper to reference which of the two buffers now contains the sorted output sequence (a function of the number of key bits specified and the targeted device architecture).</li>
<li>An optional bit subrange <code>[begin_bit, end_bit)</code> of differentiating key bits can be specified. This can reduce overall sorting overhead and yield a corresponding performance improvement.</li>
<li>This operation requires a relatively small allocation of temporary device storage that is <em>O</em>(<code>P</code>), where <code>P</code> is the number of streaming multiprocessors on the device (and is typically a small constant relative to the input size <code>N</code>).</li>
<li>When <code>d_temp_storage</code> is <code>NULL</code>, no work is done and the required allocation size is returned in <code>temp_storage_bytes</code>.</li>
</ul>
</dd></dl>
<dl class="section user"><dt>Performance</dt><dd>Performance is similar to <a class="el" href="structcub_1_1_device_radix_sort.html#a4f555afa8ac2949d9fef49fad52a50d6" title="Sorts keys into ascending order. (~2N auxiliary storage required) ">DeviceRadixSort::SortKeys</a>.</dd></dl>
<dl class="section user"><dt>Snippet</dt><dd>The code snippet below illustrates the sorting of a device vector of <code>int</code> keys. </dd></dl>
<dl class="section user"><dt></dt><dd><div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cub_8cuh.html">cub/cub.cuh</a>&gt;</span>   <span class="comment">// or equivalently &lt;cub/device/device_radix_sort.cuh&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="comment">// Declare, allocate, and initialize device-accessible pointers for sorting data</span></div>
<div class="line"><span class="keywordtype">int</span>  num_items;          <span class="comment">// e.g., 7</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_buf;         <span class="comment">// e.g., [8, 6, 7, 5, 3, 0, 9]</span></div>
<div class="line"><span class="keywordtype">int</span>  *d_key_alt_buf;     <span class="comment">// e.g., [        ...        ]</span></div>
<div class="line">...</div>
<div class="line"></div>
<div class="line"><span class="comment">// Create a DoubleBuffer to wrap the pair of device pointers</span></div>
<div class="line">cub::DoubleBuffer&lt;<span class="keywordtype">int</span>&gt; d_keys(d_key_buf, d_key_alt_buf);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Determine temporary device storage requirements</span></div>
<div class="line"><span class="keywordtype">void</span>     *d_temp_storage = NULL;</div>
<div class="line"><span class="keywordtype">size_t</span>   temp_storage_bytes = 0;</div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a24761009c4cc15fd2e54cb72663af0ef" title="Sorts keys into descending order. (~2N auxiliary storage required). ">cub::DeviceRadixSort::SortKeysDescending</a>(d_temp_storage, temp_storage_bytes, d_keys, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Allocate temporary storage</span></div>
<div class="line">cudaMalloc(&amp;d_temp_storage, temp_storage_bytes);</div>
<div class="line"></div>
<div class="line"><span class="comment">// Run sorting operation</span></div>
<div class="line"><a class="code" href="structcub_1_1_device_radix_sort.html#a24761009c4cc15fd2e54cb72663af0ef" title="Sorts keys into descending order. (~2N auxiliary storage required). ">cub::DeviceRadixSort::SortKeysDescending</a>(d_temp_storage, temp_storage_bytes, d_keys, num_items);</div>
<div class="line"></div>
<div class="line"><span class="comment">// d_keys.Current()      &lt;-- [9, 8, 7, 6, 5, 3, 0]</span></div>
</div><!-- fragment --></dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">KeyT</td><td><b>[inferred]</b> KeyT type </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">d_temp_storage</td><td>Device-accessible allocation of temporary storage. When NULL, the required allocation size is written to <code>temp_storage_bytes</code> and no work is done. </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">temp_storage_bytes</td><td>Reference to size in bytes of <code>d_temp_storage</code> allocation </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">d_keys</td><td>Reference to the double-buffer of keys whose "current" device-accessible buffer contains the unsorted input keys and, upon return, is updated to point to the sorted output keys </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num_items</td><td>Number of items to sort </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">begin_bit</td><td><b>[optional]</b> The least-significant bit index (inclusive) needed for key comparison </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">end_bit</td><td><b>[optional]</b> The most-significant bit index (exclusive) needed for key comparison (e.g., sizeof(unsigned int) * 8) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stream</td><td><b>[optional]</b> CUDA stream to launch kernels within. Default is stream<sub>0</sub>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">debug_synchronous</td><td><b>[optional]</b> Whether or not to synchronize the stream after every kernel launch to check for errors. Also causes launch configurations to be printed to the console. Default is <code>false</code>. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="device__radix__sort_8cuh_source.html#l00754">754</a> of file <a class="el" href="device__radix__sort_8cuh_source.html">device_radix_sort.cuh</a>.</p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="device__radix__sort_8cuh_source.html">device_radix_sort.cuh</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.3.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Mar 21 2016 13:28:12 for CUB by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.4
<br>
&copy; 2013 NVIDIA Corporation
</small></address>
</body>
</html>

\chapter{Input File Command Reference}\label{chap:InputFileCommandReference}
The \textit{input} file can accept a large number of commands, and this chapter gives a comprehensive list of all the options and what they do. Commands are in the form \textit{category}:\textit{keyword}=\textit{value}, where \textit{value} can be optional depending on the keyword.

\section*{System Generation}
\addcontentsline{toc}{section}{System Generation}
The following commands control generation of the simulated system, including dimensions, crystal structures etc. \\ \par

{\zicf create:full}\addcontentsline{toc}{subsection}{create:full} Uses the entire generated system without any truncation or consideration of the \textit{create:particle-size} parameter. \textit{create:full} should be used when importing a complete system, such as a complete nanoparticle and where a further definition of the system shape is not required. This is the default if no system truncation is defined.\\ \par

{\zicf create:cube}\addcontentsline{toc}{subsection}{create:cube} Cuts a cuboid particle of size \textit{$l_x$ = $l_y$ = $l_z$ = create:particle-size} from the defined crystal lattice.\\ \par

{\zicf create:cylinder}\addcontentsline{toc}{subsection}{create:cylinder} Cuts a cylindrical particle of diameter \textit{create:particle-size} from the defined crystal lattice. The height of the cylinder extends to the whole extent of the system size \textit{create:system-size-z} in the $z$-direction. \\ \par

{\zicf create:ellipsoid}\addcontentsline{toc}{subsection}{create:ellipsoid} Cuts an ellipsoid particle of diameter \textit{create:particle-size} with fractional diameters of \textit{dimensions:particle-shape-factor-x,dimensions:particle-shape-factor-y,dimensions:particle-shape-factor-z} from the defined crystal lattice.\\ \par

{\zicf create:sphere}\addcontentsline{toc}{subsection}{create:sphere} Cuts a spherical particle of diameter \textit{create:particle-size} from the defined crystal lattice.\\ \par

{\zicf create:truncated-octahedron}\addcontentsline{toc}{subsection}{create:truncated-octahedron} Cuts a truncated octahedron particle of diameter \textit{create:particle-size} from the defined crystal lattice.\\ \par

% tear drop

{\zicf create:particle}\addcontentsline{toc}{subsection}{create:particle} Defines the creation of a single particle at the centre of the defined system. If \textit{create:particle-size} is greater than the system dimensions then the outer boundary of the particle is truncated by the system dimensions. \\ \par

{\zicf create:particle-array}\addcontentsline{toc}{subsection}{create:particle-array} Defines the creation of a two-dimensional array of particles on a square lattice. The particles are separated by a distance \textit{create:particle-spacing}. If the system size is insufficient to contain at least a single entire particle of size \textit{create:particle-size} then no atoms will be generated and the program will terminate with an error.\\ \par

%{\zicf create:hexagonal-particle-array}\addcontentsline{toc}{subsection}{create:hexagonal-particle-array} Defines the creation of a two-dimensional array of particles on a hexagonal lattice. The particles are separated by a distance \textit{create:particle-spacing}. If the system size is insufficient to contain at least a single entire particle of size \textit{create:particle-size} then no atoms will be generated and the program will terminate.\\ \par

{\zicf create:voronoi-film}\addcontentsline{toc}{subsection}{create:voronoi-film} Generates a two-dimensional voronoi structure of particles, with a mean grain size of \textit{create:particle-size} and variance \textit{create:voronoi-size-variance} as a fraction of the grain size. If \textit{create:voronoi-size-variance}=0 then hexagonal shaped grains are generated. The spacing between the grains (defined by the initial voronoi seed points) is controlled by \textit{create:particle-spacing}. The pseudo-random pattern uses a predefined random seed, and so the generated structure will be the same every time. A different structure can be generated by setting a new random seed using the \textit{create:voronoi-random-seed} parameter. Depending on the desired edge structure, the first row can be shifted using the \textit{create:voronoi-row-offset} flag which changes the start point of the voronoi pattern. The \textit{create:voronoi-rounded-grains} parameter generates a voronoi structure, but then applies a grain rounding algorithm to remove the sharp edges.\\ \par

{\zicf create:voronoi-size-variance=[float]}\addcontentsline{toc}{subsection}{create:voronoi-size-variance} Controls the randomness of the voronoi grain structure. The voronoi structure is generated using a hexagonal array of seed points appropriately spaced according to the particle size and particle spacing. The seed points are then displaced in $x$ and $y$ according to a gaussian distribution of width \textit{create:voronoi-size-variance} times the particle size. The variance must be in the range 0.0-1.0. Typical values for a realistic looking grain structure are less than 0.2, and larger values will generally lead to oblique grain shapes and a large size distribution.\\
%<The grain size distribution, particle sizes, particle volumes and magnetic density are output to the voronoi.info file.> \\ \par

{\zicf create:voronoi-row-offset flag [default false]}\addcontentsline{toc}{subsection}{create:voronoi-row-offset} Offsets the first row of hexagonal points to generate a different pattern, e.g. 2,3,2 grains instead of 3,2,3 grains.\\ \par

{\zicf create:voronoi-random-seed = int}\addcontentsline{toc}{subsection}{create:voronoi-random-seed} Sets a different integer random seed for the voronoi seed point generation, and thus produces a different random grain structure.\\ \par

{\zicf create:voronoi-rounded-grains flag [default false]}\addcontentsline{toc}{subsection}{create:voronoi-rounded-grains} Controls the rounding of voronoi grains to generate more realistic grain shapes. The algorithm works by expanding a polygon from the centre of the grain, until the total volume bounded by the edges of the grain is some fraction of the total grain area, defined by \textit{create:voronoi-rounded-grains-area}. This generally leads to the removal of sharp edges. \\ \par

{\zicf create:voronoi-rounded-grains-area = float [0.0-1.0, default 0.9]}\addcontentsline{toc}{subsection}{create:voronoi-rounded-grains-area} Defines the fractional grain area where the expanding polygon is constrained, in the range 0.0-1.0. Values less than 1.0 will lead to truncation of the voronoi grain shapes, and very small values will generally lead to circular grains. A typical value is 0.9 for reasonable voronoi variance.\\ \par

{\zicf create:particle-centre-offset}\addcontentsline{toc}{subsection}{create:particle-parity} shifts the origin of a particle to the centre of the nearest unit cell.\\ \par

{\zicf create:crystal-structure = string [sc,fcc,bcc; default sc]}\addcontentsline{toc}{subsection}{create:crystal-structure} Defines the default crystal lattice to be generated.\\ \par

{\zicf create:single-spin flag}\addcontentsline{toc}{subsection}{create:single-spin} Overrides all create options and generates a single isolated spin.\\ \par

{\zicf create:periodic-boundaries-x flag}\addcontentsline{toc}{subsection}{create:periodic-boundaries-x} creates periodic boundaries along the $x$-direction. Parallel version is implemented but untested - use with caution.\\ \par

{\zicf create:periodic-boundaries-y flag}\addcontentsline{toc}{subsection}{create:periodic-boundaries-y} creates periodic boundaries along the $y$-direction. Parallel version is implemented but untested - use with caution.\\ \par

{\zicf create:periodic-boundaries-z flag}\addcontentsline{toc}{subsection}{create:periodic-boundaries-z} creates periodic boundaries along the $z$-direction. Parallel version is implemented but untested - use with caution.\\ \par

{\zicf create:select-material-by-height}\addcontentsline{toc}{subsection}{create:select-material-by-height}\\ \par

{\zicf create:select-material-by-geometry}\addcontentsline{toc}{subsection}{create:select-material-by-geometry}\\ \par

{\zicf create:fill-core-shell-particles}\addcontentsline{toc}{subsection}{create:fill-core-shell-particles}\\ \par

{\zicf create:interfacial-roughness}\addcontentsline{toc}{subsection}{create:interfacial-roughness}\\ \par

{\zicf create:material-interfacial-roughness}\addcontentsline{toc}{subsection}{create:material-interfacial-roughness}\\ \par

{\zicf create:interfacial-roughness-random-seed}\addcontentsline{toc}{subsection}{create:interfacial-roughness-random-seed}\\ \par

{\zicf create:interfacial-roughness-number-of-seed-points}\addcontentsline{toc}{subsection}{create:interfacial-roughness-number-of-seed-points}\\ \par

{\zicf create:interfacial-roughness-type}\addcontentsline{toc}{subsection}{create:interfacial-roughness-type}\\ \par

{\zicf create:interfacial-roughness-seed-radius}\addcontentsline{toc}{subsection}{create:interfacial-roughness-seed-radius}\\ \par

{\zicf create:interfacial-roughness-seed-radius-variance}\addcontentsline{toc}{subsection}{create:interfacial-roughness-seed-radius-variance}\\ \par

{\zicf create:interfacial-roughness-mean-height}\addcontentsline{toc}{subsection}{create:interfacial-roughness-mean-height}\\ \par

{\zicf create:interfacial-roughness-maximum-height}\addcontentsline{toc}{subsection}{create:interfacial-roughness-maximum-height}\\ \par

{\zicf create:interfacial-roughness-height-field-resolution}\addcontentsline{toc}{subsection}{create:interfacial-roughness-height-field-resolution}\\ \par

\section*{System dimensions}
\addcontentsline{toc}{section}{System dimensions}
The commands here determine the dimensions of the generated system.\\

{\zicf dimensions:unit-cell-size = float [0.1+ \AA, default 3.54 \AA]}\addcontentsline{toc}{subsection}{dimensions:unit-cell-size} Defines the size of the unit cell.\\ \par

{\zicf dimensions:unit-cell-size-x}\addcontentsline{toc}{subsection}{dimensions:unit-cell-size-x} Defines the size of the unit cell if asymmetric.\\ \par

{\zicf dimensions:unit-cell-size-x}\addcontentsline{toc}{subsection}{dimensions:unit-cell-size-y} Defines the size of the unit cell if asymmetric.\\ \par

{\zicf dimensions:unit-cell-size-z}\addcontentsline{toc}{subsection}{dimensions:unit-cell-size-z} Defines the size of the unit cell if asymmetric.\\ \par

{\zicf dimensions:system-size}\addcontentsline{toc}{subsection}{dimensions:system-size} Defines the size of the symmetric bulk crystal. \\ \par

{\zicf dimensions:system-size-x}\addcontentsline{toc}{subsection}{dimensions:system-size-x} Defines the total size if the system along the $x$-axis.\\ \par

{\zicf dimensions:system-size-y}\addcontentsline{toc}{subsection}{dimensions:system-size-y} Defines the total size if the system along the $y$-axis.\\ \par

{\zicf dimensions:system-size-z}\addcontentsline{toc}{subsection}{dimensions:system-size-z} Defines the total size if the system along the $z$-axis.\\ \par

{\zicf dimensions:particle-size = float}\addcontentsline{toc}{subsection}{dimensions:particle-size} Defines the size of particles cut from the bulk crystal.\\ \par

{\zicf dimensions:particle-spacing}\addcontentsline{toc}{subsection}{dimensions:particle-spacing} Defines the spacing between particles in particle arrays or voronoi media.\\ \par


{\zicf dimensions:particle-shape-factor-x = float [0.001-1, default 1.0]}\addcontentsline{toc}{subsection}{dimensions:particle-shape-factor-z} Modifies the default particle shape to create elongated particles. The selected particle shape is modified by changing the effective particle size in the $x$ direction. This property scales the as a fraction of the particle-size along the $x$-direction.\\

{\zicf dimensions:particle-shape-factor-y = float [0.001-1, default 1.0]}\addcontentsline{toc}{subsection}{dimensions:particle-shape-factor-y}\\

{\zicf dimensions:particle-shape-factor-z = float [0.001-1, default 1.0]}\addcontentsline{toc}{subsection}{dimensions:particle-shape-factor-z}\\

{\zicf dimensions:particle-array-offset-x [0-10$^4$ \AA]}\addcontentsline{toc}{subsection}{dimensions:particle-array-offset-x} Translates the 2-D particle array the chosen distance along the x-direction.\\

{\zicf dimensions:particle-array-offset-y}\addcontentsline{toc}{subsection}{dimensions:particle-array-offset-y}\\

{\zicf dimensions:double macro-cell-size}\addcontentsline{toc}{subsection}{dimensions:macro-cell-size} determines the macro cell size for calculation of the demagnetizing field and output of the magnetic configuration. Finer discretisation lead to more accurate results at the cost of significantly longer run times. The cell size should always be less than the system size, as highly asymmetric cells will leads to significant errors in the demagnetisation field calculation.

\section*{Simulation Control}
\addcontentsline{toc}{section}{Simulation Control}
The following commands control the simulation, including the program, maximum temperatures, applied filed strength etc.\\

{\zicf sim:integrator = exclusive string [default llg-heun]}\addcontentsline{toc}{subsection}{sim:integrator} Declares the integrator to be used for the simulation. Available options are:
\begin{itemize}
  \item[] llg-heun
  \item[] monte-carlo
  \item[] llg-midpoint
  \item[] constrained-monte-carlo
  \item[] hybrid-constrained-monte-carlo
\end{itemize}

{\zicf sim:program = exclusive bool}\addcontentsline{toc}{subsection}{sim:program} defines the simulation program to be used.\\

{\zicf sim:program = benchmark}\addcontentsline{toc}{subsubsection}{benchmark} program which integrates the system for 10,000 time steps and exits. Used primarily for quick performance comparisons for different system architectures, processors and during code performance optimisation.\\

{\zicf sim:program = time-series}\addcontentsline{toc}{subsubsection}{time-series} program to perform a single time series typically used for switching calculations, ferromagnetic resonance or to find equilibrium magnetic configurations. The system is usually simulated with constant temperature and applied field. The system is first equilibrated for \textit{sim:equilibration-time-steps} time steps and is then integrated for \textit{sim:time-steps} time steps.\\

{\zicf sim:program = hysteresis-loop}\addcontentsline{toc}{subsubsection}{hysteresis-loop} program to simulate a dynamic hysteresis loop in user defined field range and precision. The system temperature is fixed and defined by \textit{sim:temperature}. The system is first equilibrated for \textit{sim:equilibration time-steps} time steps at \textit{sim:maximum-applied-field-strength} applied field. For normal loops \textit{sim:maximum-applied-field-strength} should be a saturating field. After equilibration the system is integrated for \textit{sim:loop-time-steps} at each field point. The field increments from +\textit{sim:maximum-applied-field-strength} to =\textit{sim:maximum-applied-field-strength} in steps of \textit{sim:applied-field-increment}, and data is output after each field step.\\

{\zicf sim:program = static-hysteresis-loop}\addcontentsline{toc}{subsubsection}{static-hysteresis-loop} program to perform a hysteresis loop in the same way as a normal hysteresis loop, but instead of a dynamic loop the equilibrium condition is found by minimisation of the torque on the system. For static loops the temperature must be zero otherwise the torque is always finite. At each field increment the system is integrated until either the maximum torque for any one spin is less than the tolerance value ($10^{-6}$ T), or if \textit{sim:loop-time-steps} is reached. Generally static loops are computationally efficient, and so \textit{sim:loop-time-steps} can be large, as many integration steps are only required during switching, i.e. near the coercivity.\\

{\zicf sim:program = curie-temperature}\addcontentsline{toc}{subsubsection}{curie-temperature} Simulates a temperature loop to determine the Curie temperature of the system. The temperature of the system is increased stepwise, starting at \textit{sim:minimum} temperature and ending at \textit{sim:maximum-temperature} in steps of \textit{sim:temperature-increment}. At each temperature the system is first equilibrated for \textit{sim:equilibration-steps} time steps and then a statistical average is taken over \textit{sim:loop-time-steps}. In general the Monte Carlo integrator is the optimal method for determining the Curie temperature, and typically a few thousand steps is sufficient to equilibrate the system. To determine the Curie temperature it is best to plot the mean magnetization length at each temperature, which can be specified using the \textit{output:mean-magnetisation-length} keyword. Typically the temperature dependent magnetization cen be fitted using the function
\begin{equation}
m(T) = <\sqrt{\sum_i \sms}> \left(1 - \frac{T}{T_{\mathrm{C}}} \right)^{\beta}
\end{equation}
where $T$ is the temperature, $T_{\mathrm{C}}$ is the Curie temperature, and $\beta \sim 0.34$ is the critical exponent.\\

{\zicf sim:program = field-cooling}\addcontentsline{toc}{subsubsection}{field-cooling}
\\

{\zicf sim:program = temperature-pulse}\addcontentsline{toc}{subsubsection}{temperature-pulse}\\

{\zicf sim:program = cmc-anisotropy}\addcontentsline{toc}{subsubsection}{cmc-anisotropy}\\

%    Hybrid-CMC \\
%    Reverse-Hybrid-CMC x
%    LaGrange-Multiplier x
%    Diagnostic-Boltzmann x

{\zicf sim:enable-dipole-fields flag}\addcontentsline{toc}{subsection}{sim:enable-dipole-fields} enables calculation of the demagnetising field.\\

{\zicf   sim:enable-fmr-field}\addcontentsline{toc}{subsection}{sim:enable-fmr-field}\\

{\zicf   sim:enable-fast-dipole-fields}\addcontentsline{toc}{subsection}{sim:enable-fast-dipole-fields}
     Bool default false
     Enables fast calculation of the demag field by pre calculation of the interaction matrix.\\

{\zicf sim:dipole-field-update-rate}\addcontentsline{toc}{subsection}{sim:dipole-field-update-rate}
   Integer default 1000
   Number of timesteps between recalculation of the demag field. Default value is suitable for slow calculations, fast dynamics will generally require much faster update rates.\\

{\zicf  sim:enable-surface-anisotropy}\addcontentsline{toc}{subsection}{sim:enable-surface-anisotropy}\\

{\zicf sim:surface-anisotropy-threshold}\addcontentsline{toc}{subsection}{sim:surface-anisotropy-threshold}
  Int default [native]
  Determines minimal number of neighbours to classify as surface atom.\\

{\zicf sim:surface-anisotropy-nearest-neighbour-range}\addcontentsline{toc}{subsection}{sim:surface-anisotropy-nearest-neighbour-range}
  float default [$\infty$]
  Sets the interaction range for the nearest neighbour list used for the surface anisotropy calculation.\\

{\zicf sim:time-step}\addcontentsline{toc}{subsection}{sim:time-step}\\

{\zicf sim:total-time-steps}\addcontentsline{toc}{subsection}{sim:total-time-steps}\\

{\zicf sim:loop-time-steps}\addcontentsline{toc}{subsection}{sim:loop-time-steps}\\

{\zicf sim:time-steps-increment}\addcontentsline{toc}{subsection}{sim:time-steps-increment}\\

{\zicf sim:equilibration-time-steps}\addcontentsline{toc}{subsection}{sim:equilibration-time-steps}\\

{\zicf sim:simulation-cycles}\addcontentsline{toc}{subsection}{sim:simulation-cycles}\\

{\zicf sim:maximum-temperature}\addcontentsline{toc}{subsection}{sim:maximum-temperature}\\

{\zicf sim:minimum-temperature}\addcontentsline{toc}{subsection}{sim:minimum-temperature}\\

{\zicf sim:equilibration-temperature}\addcontentsline{toc}{subsection}{sim:equilibration-temperature}\\

{\zicf sim:temperature}\addcontentsline{toc}{subsection}{sim:temperature}\\

{\zicf sim:temperature-increment}\addcontentsline{toc}{subsection}{sim:temperature-increment}\\

{\zicf sim:cooling-time}\addcontentsline{toc}{subsection}{sim:cooling-time}\\

{\zicf sim:laser-pulse-temporal-profile}\addcontentsline{toc}{subsection}{sim:laser-pulse-temporal-profile}
    square
    two-temperature
    double-pulse-two-temperature
    double-pulse-square\\

{\zicf sim:laser-pulse-time}\addcontentsline{toc}{subsection}{sim:laser-pulse-time}\\

{\zicf sim:laser-pulse-power}\addcontentsline{toc}{subsection}{sim:laser-pulse-power}\\

{\zicf sim:second-laser-pulse-time}\addcontentsline{toc}{subsection}{sim:second-laser-pulse-time}\\

{\zicf sim:second-laser-pulse-power}\addcontentsline{toc}{subsection}{sim:second-laser-pulse-power}\\

{\zicf sim:second-laser-pulse-maximum-temperature}\addcontentsline{toc}{subsection}{sim:second-laser-pulse-maximum-temperature}\\

{\zicf sim:second-laser-pulse-delay-time}\addcontentsline{toc}{subsection}{sim:second-laser-pulse-delay-time}\\

{\zicf sim:two-temperature-heat-sink-coupling}\addcontentsline{toc}{subsection}{sim:two-temperature-heat-sink-coupling}\\

{\zicf sim:two-temperature-electron-heat-capacity}\addcontentsline{toc}{subsection}{sim:two-temperature-electron-heat-capacity}\\

{\zicf sim:two-temperature-phonon-heat-capacity}\addcontentsline{toc}{subsection}{sim:two-temperature-phonon-heat-capacity}\\

{\zicf sim:two-temperature-electron-phonon-coupling}\addcontentsline{toc}{subsection}{sim:two-temperature-electron-phonon-coupling}\\

{\zicf sim:cooling-function}\addcontentsline{toc}{subsection}{sim:cooling-function}
    exponential
    gaussian
    double-gaussian
    linear\\

{\zicf sim:applied-field-strength}\addcontentsline{toc}{subsection}{sim:applied-field-strength}\\

%{\zicf   minimum-applied-field-strength x
{\zicf  sim:maximum-applied-field-strength}\addcontentsline{toc}{subsection}{sim:maximum-applied-field-strength}\\

{\zicf sim:equilibration-applied-field-strength}\addcontentsline{toc}{subsection}{sim:equilibration-applied-field-strength}\\

{\zicf sim:applied-field-strength-increment}\addcontentsline{toc}{subsection}{sim:applied-field-strength-increment}\\

{\zicf sim:applied-field-angle-theta}\addcontentsline{toc}{subsection}{sim:applied-field-angle-theta}\\

{\zicf sim:applied-field-angle-phi}\addcontentsline{toc}{subsection}{sim:applied-field-angle-phi}\\

{\zicf sim:applied-field-unit-vector}\addcontentsline{toc}{subsection}{sim:applied-field-unit-vector}\\
%  Hx x
%  Hy x
%  Hz x
%  External-Demag x
%  Bool default false

{\zicf sim:demagnetisation-factor = float vector [default (000)]}\addcontentsline{toc}{subsection}{sim:demagnetisation-factor} vector describing the components of the demagnetising factor from a macroscopic sample. By default this is disabled, and specifying a demagnetisation factor adds an effective field, such that the total field is given by:
\begin{equation*}
\mathbf{H}_{\mathrm{tot}} = \mathbf{H}_{\mathrm{ext}} + \mathbf{H}_{\mathrm{int}} - \mathbf{M} \cdot \mathbf{N}_{\mathrm{d}}
\end{equation*}
where $\mathbf{M}$ is the magnetisation of the sample and $\mathbf{N}_{\mathrm{d}}
$ is the demagnetisation factor of the macroscopic sample. The components of the demagnetisation factor must sum to 1. In general the demagnetisation factor should be used without the dipolar field, as this results in counting the demagnetising effects twice. However, the possibility of using both is not prevented by the code.\\

{\zicf sim:mpi-mode}\addcontentsline{toc}{subsection}{sim:mpi-mode}
    geometric-decomposition
    replicated-data
    replicated-data-staged\\

%{\zicf  sim:mpi-ppn ()}\addcontentsline{toc}{subsection}{sim:mpi-ppn}\\

{\zicf sim:integrator-random-seed
    Integer [default 12345]}\addcontentsline{toc}{subsection}{sim:integrator-random-seed}
    Sets a seed for the psuedo random number generator. Simulations use a predictable sequence of psuedo random numbers to give repeatable results for the same simulation. The seed determines the actual sequence of numbers and is used to give a different realisation of the same simulation which is useful for determining statistical properties of the system.\\

{\zicf sim:constraint-rotation-update}\addcontentsline{toc}{subsection}{sim:constraint-rotation-update}\\

{\zicf sim:constraint-angle-theta = float (default 0)}\addcontentsline{toc}{subsection}{sim:constraint-angle-theta}
    When a constrained integrator is used in a normal program, this variable controls the angle of the magnetisation of the. Whole system from the x-axis [degrees]. In constrained simulations (such as c,c anisotropy) this has no effect.\\

{\zicf  sim:constraint-angle-theta-minimum float (default 0)}\addcontentsline{toc}{subsection}{sim:constraint-angle-theta-minimum}\\

{\zicf  sim:constraint-angle-theta-maximum}\addcontentsline{toc}{subsection}{sim:constraint-angle-theta-maximum}\\

{\zicf  sim:constraint-angle-theta-increment = float 0.001-360 (default 5)}\addcontentsline{toc}{subsection}{sim:constraint-angle-theta-increment}
    Incremental Change of angle of m from z-direction in constrained simulations. Controls the resolution of \\

{\zicf sim:constraint-angle-phi}\addcontentsline{toc}{subsection}{sim:constraint-angle-phi}\\

{\zicf sim:constraint-angle-phi-minimum}\addcontentsline{toc}{subsection}{sim:constraint-angle-phi-minimum}\\

{\zicf sim:constraint-angle-phi-maximum}\addcontentsline{toc}{subsection}{sim:constraint-angle-phi-maximum}\\

{\zicf sim:constraint-angle-phi-increment}\addcontentsline{toc}{subsection}{sim:constraint-angle-phi-increment}\\

{\zicf sim:monte-carlo-algorithm}\addcontentsline{toc}{subsection}{sim:monte-carlo-algorithm}
\begin{itemize}
  \item[] spin-flip
  \item[] uniform
  \item[] angle
  \item[] hinzke-nowak
\end{itemize}\\

{\zicf sim:checkpoint flag [default false]}\addcontentsline{toc}{subsection}{sim:checkpoint}
    Enables checkpointing of spin configuration at end of simulation
sim:save-checkpoint=end
sim:save-checkpoint=continuous
sim:save-checkpoint-rate=1
sim:load-checkpoint=restart
sim:load-checkpoint=continue\\

{\zicf sim:preconditioning-steps
    integer [default 0]}\addcontentsline{toc}{subsection}{sim:preconditioning-steps}
    defines a number of preconditioning steps to thermalise the spins at
    sim:equilibration-temperature prior to the main simulation starting. The
    preconditioner uses a Monte Carlo algorithm to develop a Boltzmann spin
    distribution prior to the main program starting. The method works in serial
    and parallel mode and is especially efficient for materials with low Gilbert
    damping. The preconditioning steps are applied after loading a checkpoint,
    allowing you to take a low temperature starting state and thermally
    equilibrate it.\\

\section*{Data output}
\addcontentsline{toc}{section}{Data output}
The following commands control what data is output to the \textit{output} file. The order in which they appear is the order in which they appear in the \textit{output} file. Most options output a single column of data, but some output multiple columns, particularly vector data or parameters related to materials, where one column per material is output.\\

{\zicf output:time-steps}\addcontentsline{toc}{subsection}{output:time-steps} outputs the number of time steps (or Monte Carlo steps) completed during the simulation so far.\\

{\zicf output:real-time}\addcontentsline{toc}{subsection}{output:real-time} outputs the simulation time in seconds. The real time is given by the number of time steps multiplied by sim:time-step (default value is $1.0 \times 10^{-15}$ s. The real time has no meaning for Monte Carlo simulations.\\

{\zicf output:temperature}\addcontentsline{toc}{subsection}{output:temperature} outputs the instantaneous system temperature in Kelvin.\\

{\zicf output:applied-field-strength}\addcontentsline{toc}{subsection}{output:applied-field-strength} outputs the strength of the applied field in Tesla. For hysteresis simulations the sign of the applied field strength changes along a fixed axis and is represented in the output by a similar change in sign.\\

{\zicf output:applied-field-unit-vector}\addcontentsline{toc}{subsection}{output:applied-field-unit-vector} outputs a unit vector in three columns $\hat{h_x}$, $\hat{h_y}$, $\hat{h_z}$ indicating the direction of the external applied field.\\

{\zicf output:applied-field-alignment}\addcontentsline{toc}{subsection}{output:applied-field-alignment} outputs the dot product of the net magnetization direction of the system with the external applied field direction $\hat{\mathbf{m}} \cdot \hat{\mathbf{H}}$.\\

{\zicf output:material-applied-field-alignment}\addcontentsline{toc}{subsection}{output:material-applied-field-alignment} outputs the dot product of the net magnetization direction of each material defined in the \textit{material} file with the external applied field direction $\left[\hat{\mathbf{m}}_1 \cdot \hat{\mathbf{H}}\right]$, $\left[\hat{\mathbf{m}}_2 \cdot \hat{\mathbf{H}}\right]$...$\left[\hat{\mathbf{m}}_n \cdot \hat{\mathbf{H}}\right]$.\\

{\zicf output:magnetisation}\addcontentsline{toc}{subsection}{output:magnetisation} outputs the instantaneous magnetization of the system. The data is output in four columns $\hat{m_x}$, $\hat{m_y}$, $\hat{m_z}$, $|m|$ giving the unit vector direction of the magnetization and normalized length of the magnetization respectively. The normalized length of the magnetization $|m| = |\sum_i \mu_i S_i| / \sum \mu_i$ is given by the sum of all moments in the system assuming ferromagnetic alignment of all spins. Note that the localized spin moments $\mu_i$ are taken into account in the summation.\\

{\zicf output:magnetisation-length}\addcontentsline{toc}{subsection}{output:magnetisation-length} outputs the instantaneous normalized magnetization length $|m| = |\sum_i \mu_i S_i| / \sum \mu_i$, where the saturation value is defined by ferromagnetic alignment of all spins in the system. Note that the localized spin moments $\mu_i$ are taken into account in the summation.\\

{\zicf output:mean-magnetisation-length}\addcontentsline{toc}{subsection}{output:mean-magnetisation-length} outputs the time-averaged normalized magnetization length $\langle|m|\rangle$.\\

{\zicf output:mean-magnetisation}\addcontentsline{toc}{subsection}{output:mean-magnetisation} outputs the time-averaged normalized magnetization vector $\langle|\mathbf{m}|\rangle$.\\

{\zicf output:material-magnetisation}\addcontentsline{toc}{subsection}{output:material-magnetisation} outputs the instantaneous normalized magnetization for each material in the simulation. The data is output in blocks of four columns, with one block per material defined in the \textit{material} file, e.g.

\begin{center}
$\left[ \hat{m_1^x} \textrm{,} \hat{m_1^y} \textrm{,} \hat{m_1^z} \textrm{,} |m_1| \right]$,
$\left[ \hat{m_2^x} \textrm{,} \hat{m_2^y} \textrm{,} \hat{m_2^z} \textrm{,} |m_2| \right]$ ...
$\left[ \hat{m_n^x} \textrm{,} \hat{m_n^y} \textrm{,} \hat{m_n^z} \textrm{,} |m_n| \right]$
\end{center}

Note that obtaining the actual macroscopic magnetization length from this data is not trivial, since it is necessary to know how many atoms of each material are in the system. This information is contained within the log file (giving the fraction of atoms which make up each material). However it is usual to also output the total normalized magnetization of the system to give the relative ordering of the entire system.\\

{\zicf output:material-mean-magnetisation-length}\addcontentsline{toc}{subsection}{output:material-mean-magnetisation-length} outputs the time-averaged normalized magnetization length for each material, e.g. $\langle|m_1|\rangle$, $\langle|m_2|\rangle$...$\langle|m_n|\rangle$.\\

{\zicf output:material-mean-magnetisation}\addcontentsline{toc}{subsection}{output:material-mean-magnetisation} outputs the time-averaged normalized magnetization length for each material, e.g. $\langle|\mathbf{m}_1|\rangle$, $\langle|\mathbf{m}_2|\rangle$...$\langle|\mathbf{m}_n|\rangle$.\\

{\zicf output:total-torque}\addcontentsline{toc}{subsection}{output:total-torque} outputs the instantaneous components of the torque on the system $\tau = \sum_i \mu_i \mathbf{S}_i \times \mathbf{H}_i$ in three columns $\tau_x$, $\tau_y$, $\tau_z$ (units of Joules). In equilibrium the total torque will be close to zero, but is useful for testing convergence to an equilibrium state for zero temperature simulations.\\

{\zicf output:mean-total-torque}\addcontentsline{toc}{subsection}{output:mean-total-torque} outputs the time average of components of the torque on the system $\langle\tau\rangle = \langle\sum_i \mu_i \mathbf{S}_i \times \mathbf{H}_i \rangle$ in three columns $\langle\tau_x \rangle$, $\langle\tau_y \rangle$, $\langle\tau_z \rangle$. In equilibrium the total torque will be close to zero, but the average torque is useful for extracting effective anisotropies or exchange using constrained Monte Carlo simulations.\\

{\zicf output:constraint-phi}\addcontentsline{toc}{subsection}{output:constraint-phi} outputs the current angle of constraint from the $z$-axis for constrained simulations using either the Lagrangian Multiplier Method (LMM) or Constrained Monte Carlo (CMC) integration methods.\\

{\zicf output:constraint-theta}\addcontentsline{toc}{subsection}{output:constraint-theta} outputs the current angle of constraint from the $x$-axis for constrained simulations using either the Lagrangian Multiplier Method (LMM) or Constrained Monte Carlo (CMC) integration methods.\\

%{\zicf output:material-constraint-phi}\addcontentsline{toc}{subsection}{output:material-constraint-phi}\\

%{\zicf output:material-constraint-theta}\addcontentsline{toc}{subsection}{output:material-constraint-theta}\\

{\zicf output:material-mean-torque}\addcontentsline{toc}{subsection}{output:material-mean-torque} outputs the time average of components of the torque on the each material system $\langle\tau\rangle$ in blocks of three columns, with one block for each material defined in the \textit{material} file e.g.

\begin{center}
$\left[ \langle\tau_1^x \rangle \right.$, $\langle\tau_1^y \rangle$, $\left. \langle\tau_1^z \rangle \right]$,
$\left[ \langle\tau_2^x \rangle \right.$, $\langle\tau_2^y \rangle$, $\left. \langle\tau_2^z \rangle \right]$...
$\left[ \langle\tau_n^x \rangle \right.$, $\langle\tau_n^y \rangle$, $\left. \langle\tau_n^z \rangle \right]$
\end{center}

Computing the torque on each material is particularly useful for determining equilibrium properties of multi-component systems with constrained Monte Carlo simulations. In certain cases the components of a system (different materials) can exert equal and opposite torques on each other, giving a total system torque of zero. The decomposition of the torques for each material allows the determination of internal torques in the system.\\

{\zicf output:mean-susceptibility}\addcontentsline{toc}{subsection}{output:mean-susceptibility} outputs the components of the magnetic susceptibility $\chi$. The magnetic susceptibility is defined by
\begin{equation*}
\chi_{\alpha} = \frac{\sum_i \mu_i}{k_{\mathrm{B}}T}\left(\langle m_{\alpha}^2\rangle - \langle m_{\alpha}\rangle^2 \right)
\end{equation*}
where $\alpha = x,y,z,m$ giving the directional components of the magnetization in $x$, $y$ and $z$ respectively as well as the longitudinal susceptibility $\chi_m$. The data is output in four columns $\chi_x$, $\chi_y$, $\chi_z$, and $\chi_m$. The susceptibility is useful for identifying the critical temperature for a system as well as atomistic parametrization of the micromagnetic  Landau-Lifshitz-Bloch (LLB) equation.\\

{\zicf output:material-mean-susceptibility}\addcontentsline{toc}{subsection}{output:mean-material-susceptibility} outputs
the components of the magnetic susceptibility $\chi$ for each defined material in the system. The data is output in sets of
four columns $\chi_x$, $\chi_y$, $\chi_z$, and $\chi_m$ for each material. In multi-sublattice systems the susceptibility of
each sublattice can be different.\\

{\zicf output:electron-temperature}\addcontentsline{toc}{subsection}{output:electron-temperature} outputs the instantaneous electron temperature as calculated from the two temperature model.\\

{\zicf output:phonon-temperature}\addcontentsline{toc}{subsection}{output:phonon-temperature} outputs the instantaneous phonon (lattice) temperature as calculated from the two temperature model.\\

%{\zicf output:material-temperature}\addcontentsline{toc}{subsection}{output:material-temperature}\\

%{\zicf output:material-applied-field-strength}\addcontentsline{toc}{subsection}{output:material-applied-field-strength}\\

%{\zicf output:material-fmr-field-strength}\addcontentsline{toc}{subsection}{output:material-fmr-field-strength}\\

{\zicf output:total-energy}\addcontentsline{toc}{subsection}{output:total-energy}\\

{\zicf output:mean-total-energy}\addcontentsline{toc}{subsection}{output:mean-total-energy}\\

{\zicf output:anisotropy-energy}\addcontentsline{toc}{subsection}{output:anisotropy-energy}\\

{\zicf output:mean-anisotropy-energy}\addcontentsline{toc}{subsection}{output:mean-anisotropy-energy}\\

{\zicf output:cubic-anisotropy-energy}\addcontentsline{toc}{subsection}{output:cubic-anisotropy-energy}\\

{\zicf output:mean-cubic-anisotropy-energy}\addcontentsline{toc}{subsection}{output:mean-cubic-anisotropy-energy}\\

{\zicf output:surface-anisotropy-energy}\addcontentsline{toc}{subsection}{output:surface-anisotropy-energy}\\

{\zicf output:mean-surface-anisotropy-energy}\addcontentsline{toc}{subsection}{output:mean-surface-anisotropy-energy}\\

{\zicf output:exchange-energy}\addcontentsline{toc}{subsection}{output:exchange-energy}\\

{\zicf output:mean-exchange-energy}\addcontentsline{toc}{subsection}{output:mean-exchange-energy}\\

{\zicf output:applied-field-energy}\addcontentsline{toc}{subsection}{output:applied-field-energy}\\

{\zicf output:mean-applied-field-energy}\addcontentsline{toc}{subsection}{output:mean-applied-field-energy}\\

{\zicf output:magnetostatic-energy}\addcontentsline{toc}{subsection}{output:magnetostatic-energy}\\

{\zicf output:mean-magnetostatic-energy}\addcontentsline{toc}{subsection}{output:mean-magnetostatic-energy}\\

{\zicf output:second-order-uniaxial-anisotropy-energy}\addcontentsline{toc}{subsection}{output:second-order-uniaxial-anisotropy-energy}\\

{\zicf output:mean-second-order-uniaxial-anisotropy-energy}\addcontentsline{toc}{subsection}{output:mean-second-order-uniaxial-anisotropy-energy}\\

{\zicf output:mpi-timings}\addcontentsline{toc}{subsection}{output:mpi-timings}\\

{\zicf output:gnuplot-array-format}\addcontentsline{toc}{subsection}{output:gnuplot-array-format}\\

{\zicf output:output-rate = integer [default 1]}\addcontentsline{toc}{subsection}{output:output-rate} controls the number of data points written to the output file or printed to screen. By default \vampire calculates statistics once every sim:time-steps-increment number of time steps. Usually you want to output the updated statistic (e.g. magnetization) every time, which is the default behaviour. However, sometimes you may want to plot the time evolution of an average, where you want to collect statistics much more frequently than you output to the output file, which is controlled by this keyword. For example, if output:output-rate = 10 and sim:time-steps-increment = 10 then statistics (and average values) will be updated once every 10 time steps, and the new statistics will be written to the output file every 100 time steps.\\

\section*{Configuration output}
\addcontentsline{toc}{section}{Configuration output}
These options enable the output of spin configuration snapshots during the
simulation. The configurations can then be visualised using povray or other
software generated with the vampire data converter (vdc) utility.\\

{\zicf config:atoms flag}\addcontentsline{toc}{subsection}{config:atoms} enables
the output of atomic spin configurations.\\

{\zicf config:atoms-output-rate = int [0+, default 1000]}\addcontentsline{toc}{subsection}{config:atoms-output-rate}
determines the rate configuration files are outputted as a multiple of \textit{sim:time-steps-increment}.\\

The following options allow a cubic slice of the total configuration data to
be output to the configuration file. This is useful for reducing disk usage and
processing times, especially for large sale simulations.\\

{\zicf config:atoms-minimum-x = float [0.0 - 1.0]}\addcontentsline{toc}{subsection}{config:atoms-min-x}
determines the minimum x value (as a fraction of the total system dimensions)
of the data slice to be outputted to the configuration file.\\

{\zicf config:atoms-minimum-y}\addcontentsline{toc}{subsection}{config:atoms-min-y}
determines the minimum y value (as a fraction of the total system dimensions)
of the data slice to be outputted to the configuration file.\\

{\zicf config:atoms-minimum-z}\addcontentsline{toc}{subsection}{config:atoms-min-z}
determines the minimum z value (as a fraction of the total system dimensions)
of the data slice to be outputted to the configuration file.\\

{\zicf config:atoms-maximum-x}\addcontentsline{toc}{subsection}{config:atoms-max-x}
determines the maximum x value (as a fraction of the total system dimensions)
of the data slice to be outputted to the configuration file.\\

{\zicf config:atoms-maximum-y}\addcontentsline{toc}{subsection}{config:atoms-max-y}
determines the maximum y value (as a fraction of the total system dimensions)
of the data slice to be outputted to the configuration file.\\

{\zicf config:atoms-maximum-z}\addcontentsline{toc}{subsection}{config:atoms-max-z}
determines the maximum z value (as a fraction of the total system dimensions)
of the data slice to be outputted to the configuration file.\\

{\zicf config:macro-cells}\addcontentsline{toc}{subsection}{config:macro-cells}
enables the output of macro cell spin configurations.\\

{\zicf config:macro-cells-output-rate}\addcontentsline{toc}{subsection}{config:macro-cells-output-rate}\\
determines the rate configuration files are outputted as a multiple of \textit{sim:time-steps-increment}.\\

{\zicf config:output-format = exclusive string [default text]}\addcontentsline{toc}{subsection}{config:output-format}
specifies the format of the configuration data. Available options are:
\begin{itemize}
  \item[] text
  \item[] binary
\end{itemize}
The text option outputs data files as plain text, allowing them to be read by
a wide range of applications and hence the highest portability. There is a
performance cost to using text mode and so this is recommended only if you need
portable data and will not be using the vampire data converter (vdc) utility. The
binary option outputs the data in binary format and is typically 100 times
faster than text mode. This is important for large-scale simulations on large
numbers of processors where the data output can take a significant amount of
time. Binary files are generally not compatible between operating systems and so
the vdc tools generally needs to be run on the same system which generated the
files.\\

{\zicf config:output-mode = exclusive string [default file-per-node]}\addcontentsline{toc}{subsection}{config:output-mode}
specifies how configuration data is outputted to disk.
Available options are:
\begin{itemize}
  \item[] file-per-node
  \item[] file-per-process
  \item[] mpi-io
\end{itemize}
Using this option is important for obtaining good performance on Tier-0
(European) and Tier-1 (National) supercomputers for simulations typically using
more than 1000 cores. Large scale supercomputers have high performance parallel
file systems with a peak bandwidth typically over 10 GB/s. \vampire supports
three different modes of data output: file-per-node (FPN), file-per-process
(FPP) and mpi-io. Note that high performance requires
config:output-format = binary to be set to output the data in binary format, but
this is not default behaviour for easier data analysis and portability for the
casual user.

The first (default) option of file-per-node collates data from
different processes onto a defined number of config:output-nodes before
outputting to disk, with the total data spread out with a different file per
output node. This has good performance for medium-scale simulations and above
(>100 cores) with a reasonable number of output nodes (typically 1 per physical
node). Small simulations (<100 cores) benefit from a larger number of output
processes. to maximise bandwidth fro the independent write operations. For
typical simulations with > 40,000 atoms per core striping of the parallel file
system improves performance, while for less atoms striping can be detrimental
and should be disabled. This option is also best for distributed file systems,
typical on local resources such as university clusters.

The file-per-process option means every process in the simulation outputs its
own data to disk independent of all others. The option is available for advanced
tuning but is generally not recommended for typical simulations due to the large
number of small files generated, complicating data analysis and generally having
very poor performance.

The mpi-io option uses the MPI library routines to output a large, single shared
file. Enabling this option automatically forces binary data output. In general
this option gives good performance for large systems with a single file for each
configuration snapshot. In general this gives worse performance than the
file-per-node option except for the largest system sizes.\\

{\zicf config:output-nodes = int [default 1]}\addcontentsline{toc}{subsection}{config:output-nodes}
Specifies the number of files to be generated per snapshot. For typical small
scale simulations (on a single physical node) the default value of 1 is fine.
For larger scale simulations more output nodes are beneficial to achieve maximum
performance, with one output node per physical node being a sensible choice, but
this can be specified up to the maximum number of processes in the simulation.\\
